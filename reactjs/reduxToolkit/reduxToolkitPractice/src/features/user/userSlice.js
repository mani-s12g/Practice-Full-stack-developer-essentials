import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";

const initialState = {
  loading: "idle", // 'idle' | 'pending' | 'succeeded' | 'failed'
  user: null,
  createdUser: null, // <-- NEW state for the POST response
  error: null,
};

// 1. createAsyncThunk: Handles the API call and generates the 3 action types
export const fetchUserById = createAsyncThunk(
  // Action type prefix: 'user/fetchUserById'
  "user/fetchUserById",
  // The payload creator function (the actual async logic)

  async (userId, { rejectWithValue }) => {
    try {
      const response = await fetch(
        `https://jsonplaceholder.typicode.com/users/${userId}`
      );
      if (!response.ok) {
        throw new Error(`Failed with status: ${response.status}`);
      }
      const data = response.json();
      return data; // This becomes the action.payload in the 'fulfilled' case
    } catch (error) {
      // Use rejectWithValue to return a value that becomes the action.payload
      // in the 'rejected' case
      return rejectWithValue(error.message);
    }
  }
);

// --- New createAsyncThunk for POST Request ---
export const createNewUser = createAsyncThunk(
    "user/createNewUser",
    async(userData, {rejectWithValue}) => {
        try {
            const response = await fetch('https://jsonplaceholder.typicode.com/users', {
                method: 'POST',
                headers: {
                    'Content-type': "application/json",
                },
                body: JSON.stringify(userData),
            });

            if(!response) {
                throw new Error('Failed to create user.');
            }
            const data = response.json();
            return data; // This will be the action.payload on success
        } catch (error) {
            return rejectWithValue(error.message);
        }
    }
)

// 2. createSlice: Defines the reducer logic and synchronous actions
const userSlice = createSlice({
  name: "user",
  initialState,
  reducers: {
    // We don't need manual sync actions for the API lifecycle here
    // But this is where you'd put a synchronous 'clearUser' action:
    clearUser: (state) => {
      state.user = null; // Thanks to Immer, this "mutation" is safe!
    },
  },
  // 3. extraReducers: Connects the slice to the actions generated by createAsyncThunk
  extraReducers: (builder) => {
    builder
    // Case 1: The async call is PENDING
    .addCase(fetchUserById.pending, (state) => {
        state.loading = 'pending',
        state.error = null;
    })
    // Case 2: The async call is FULFILLED (Success)
    .addCase(fetchUserById.fulfilled, (state, action) => {
        state.loading = 'succeeded',
        state.user = action.payload; // Payload is the data returned from the async function
    })
    // Case 3: The async call is REJECTED (Failure)
    .addCase(fetchUserById.rejected, (state, action) => {
        state.loading = 'failed',
        state.error = action.payload,
        state.user = null;
    })
    // --- New Cases for the CREATE (POST) Thunk ---
    .addCase(createNewUser.pending, (state) => {
        state.loading = 'pending';
        state.error = null;
        state.createdUser = null;
    })
    .addCase(createNewUser.fulfilled, (state, action) => {
        state.loading = 'succeeded',
        state.createdUser = action.payload; // Store the created user
        state.error = null;
    })
    .addCase(createNewUser.rejected, (state, action) => {
        state.loading = 'failed',
        state.error = action.payload,
        state.createdUser = null;
    });
  },
});

export const {clearUser} = userSlice.actions;
export default userSlice.reducer;