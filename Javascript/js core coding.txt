# Frontend DSA Interview Questions for FAANG & Product Companies
## For 4-5 Years Experience React.js Developers

---

## **1. Array & String Manipulation**

### Two Sum / Two Pointers
```javascript
// Find two numbers that add up to target
function twoSum(nums, target) {
  const map = new Map();
  for (let i = 0; i < nums.length; i++) {
    const complement = target - nums[i];
    if (map.has(complement)) {
      return [map.get(complement), i];
    }
    map.set(nums[i], i);
  }
  return [];
}
```

### Debounce (Very Common for Frontend)
```javascript
function debounce(fn, delay) {
  let timeoutId;
  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn.apply(this, args), delay);
  };
}
```

### Throttle
```javascript
function throttle(fn, limit) {
  let inThrottle;
  return function(...args) {
    if (!inThrottle) {
      fn.apply(this, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}
```

### Flatten Array (Deep Flatten)
```javascript
function flatten(arr) {
  return arr.reduce((acc, val) => 
    Array.isArray(val) ? acc.concat(flatten(val)) : acc.concat(val), 
  []);
}

// Alternative
function flattenIterative(arr) {
  const stack = [...arr];
  const result = [];
  while (stack.length) {
    const next = stack.pop();
    if (Array.isArray(next)) {
      stack.push(...next);
    } else {
      result.push(next);
    }
  }
  return result.reverse();
}
```

### Group Anagrams
```javascript
function groupAnagrams(strs) {
  const map = new Map();
  for (let str of strs) {
    const sorted = str.split('').sort().join('');
    if (!map.has(sorted)) {
      map.set(sorted, []);
    }
    map.get(sorted).push(str);
  }
  return Array.from(map.values());
}
```

---

## **2. Object & Data Manipulation**

### Deep Clone
```javascript
function deepClone(obj, hash = new WeakMap()) {
  if (obj === null || typeof obj !== 'object') return obj;
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);
  
  if (hash.has(obj)) return hash.get(obj); // Handle circular references
  
  const cloneObj = Array.isArray(obj) ? [] : {};
  hash.set(obj, cloneObj);
  
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      cloneObj[key] = deepClone(obj[key], hash);
    }
  }
  return cloneObj;
}
```

### Deep Equal / Object Comparison
```javascript
function deepEqual(obj1, obj2) {
  if (obj1 === obj2) return true;
  
  if (typeof obj1 !== 'object' || typeof obj2 !== 'object' || 
      obj1 === null || obj2 === null) {
    return false;
  }
  
  const keys1 = Object.keys(obj1);
  const keys2 = Object.keys(obj2);
  
  if (keys1.length !== keys2.length) return false;
  
  for (let key of keys1) {
    if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) {
      return false;
    }
  }
  return true;
}
```

### Flatten Object
```javascript
function flattenObject(obj, prefix = '') {
  return Object.keys(obj).reduce((acc, key) => {
    const pre = prefix.length ? prefix + '.' : '';
    if (typeof obj[key] === 'object' && obj[key] !== null && !Array.isArray(obj[key])) {
      Object.assign(acc, flattenObject(obj[key], pre + key));
    } else {
      acc[pre + key] = obj[key];
    }
    return acc;
  }, {});
}

// Example: {a: {b: {c: 1}}} => {'a.b.c': 1}
```

### Get/Set Nested Property by Path
```javascript
function get(obj, path, defaultValue) {
  const keys = path.split('.');
  let result = obj;
  for (let key of keys) {
    result = result?.[key];
    if (result === undefined) return defaultValue;
  }
  return result;
}

function set(obj, path, value) {
  const keys = path.split('.');
  const lastKey = keys.pop();
  const lastObj = keys.reduce((o, k) => o[k] = o[k] || {}, obj);
  lastObj[lastKey] = value;
  return obj;
}
```

---

## **3. DOM & Tree Traversal**

### Binary Tree Level Order Traversal
```javascript
function levelOrder(root) {
  if (!root) return [];
  const result = [];
  const queue = [root];
  
  while (queue.length) {
    const levelSize = queue.length;
    const currentLevel = [];
    
    for (let i = 0; i < levelSize; i++) {
      const node = queue.shift();
      currentLevel.push(node.val);
      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    }
    result.push(currentLevel);
  }
  return result;
}
```

### DOM Tree Traversal (BFS & DFS)
```javascript
// BFS
function bfsDOM(root) {
  const result = [];
  const queue = [root];
  
  while (queue.length) {
    const node = queue.shift();
    result.push(node);
    queue.push(...node.children);
  }
  return result;
}

// DFS
function dfsDOM(root, result = []) {
  result.push(root);
  for (let child of root.children) {
    dfsDOM(child, result);
  }
  return result;
}
```

### Find DOM Node by ClassName/ID
```javascript
function getElementsByClassName(root, className) {
  const result = [];
  
  function traverse(node) {
    if (node.classList?.contains(className)) {
      result.push(node);
    }
    for (let child of node.children || []) {
      traverse(child);
    }
  }
  
  traverse(root);
  return result;
}
```

---

## **4. Async & Promises**

### Implement Promise.all
```javascript
function promiseAll(promises) {
  return new Promise((resolve, reject) => {
    if (!Array.isArray(promises)) {
      return reject(new TypeError('Argument must be an array'));
    }
    
    const results = [];
    let completed = 0;
    
    if (promises.length === 0) {
      resolve(results);
      return;
    }
    
    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then(value => {
          results[index] = value;
          completed++;
          if (completed === promises.length) {
            resolve(results);
          }
        })
        .catch(reject);
    });
  });
}
```

### Implement Promise.allSettled
```javascript
function promiseAllSettled(promises) {
  return Promise.all(
    promises.map(p => 
      Promise.resolve(p)
        .then(value => ({ status: 'fulfilled', value }))
        .catch(reason => ({ status: 'rejected', reason }))
    )
  );
}
```

### Retry with Exponential Backoff
```javascript
async function retry(fn, retries = 3, delay = 1000) {
  try {
    return await fn();
  } catch (error) {
    if (retries === 0) throw error;
    await new Promise(resolve => setTimeout(resolve, delay));
    return retry(fn, retries - 1, delay * 2);
  }
}
```

### Async Task Queue with Concurrency Limit
```javascript
class TaskQueue {
  constructor(concurrency) {
    this.concurrency = concurrency;
    this.running = 0;
    this.queue = [];
  }
  
  async push(task) {
    while (this.running >= this.concurrency) {
      await new Promise(resolve => this.queue.push(resolve));
    }
    
    this.running++;
    try {
      return await task();
    } finally {
      this.running--;
      const resolve = this.queue.shift();
      if (resolve) resolve();
    }
  }
}
```

---

## **5. Caching & Memoization**

### Memoize Function
```javascript
function memoize(fn) {
  const cache = new Map();
  return function(...args) {
    const key = JSON.stringify(args);
    if (cache.has(key)) {
      return cache.get(key);
    }
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
}
```

### LRU Cache
```javascript
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = new Map();
  }
  
  get(key) {
    if (!this.cache.has(key)) return -1;
    const val = this.cache.get(key);
    this.cache.delete(key);
    this.cache.set(key, val);
    return val;
  }
  
  put(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    }
    this.cache.set(key, value);
    if (this.cache.size > this.capacity) {
      this.cache.delete(this.cache.keys().next().value);
    }
  }
}
```

---

## **6. Event Handling & Patterns**

### Event Emitter
```javascript
class EventEmitter {
  constructor() {
    this.events = {};
  }
  
  on(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(callback);
  }
  
  off(event, callback) {
    if (!this.events[event]) return;
    this.events[event] = this.events[event].filter(cb => cb !== callback);
  }
  
  emit(event, ...args) {
    if (!this.events[event]) return;
    this.events[event].forEach(callback => callback(...args));
  }
  
  once(event, callback) {
    const onceWrapper = (...args) => {
      callback(...args);
      this.off(event, onceWrapper);
    };
    this.on(event, onceWrapper);
  }
}
```

### Implement Bind/Call/Apply
```javascript
Function.prototype.myBind = function(context, ...args) {
  const fn = this;
  return function(...newArgs) {
    return fn.apply(context, [...args, ...newArgs]);
  };
};

Function.prototype.myCall = function(context, ...args) {
  context = context || globalThis;
  const fnSymbol = Symbol();
  context[fnSymbol] = this;
  const result = context[fnSymbol](...args);
  delete context[fnSymbol];
  return result;
};
```

---

## **7. Virtual DOM & Diffing**

### Simple Virtual DOM Diff
```javascript
function diff(oldNode, newNode) {
  // Different types
  if (typeof oldNode !== typeof newNode) {
    return { type: 'REPLACE', newNode };
  }
  
  // Text nodes
  if (typeof oldNode === 'string') {
    if (oldNode !== newNode) {
      return { type: 'TEXT', newNode };
    }
    return null;
  }
  
  // Tag changed
  if (oldNode.tag !== newNode.tag) {
    return { type: 'REPLACE', newNode };
  }
  
  // Check props and children
  const patches = {
    type: 'UPDATE',
    props: diffProps(oldNode.props, newNode.props),
    children: diffChildren(oldNode.children, newNode.children)
  };
  
  return patches;
}
```

---

## **8. String & Search Algorithms**

### Implement indexOf
```javascript
function indexOf(str, substr) {
  if (substr.length === 0) return 0;
  for (let i = 0; i <= str.length - substr.length; i++) {
    let match = true;
    for (let j = 0; j < substr.length; j++) {
      if (str[i + j] !== substr[j]) {
        match = false;
        break;
      }
    }
    if (match) return i;
  }
  return -1;
}
```

### Valid Parentheses
```javascript
function isValid(s) {
  const stack = [];
  const map = { ')': '(', '}': '{', ']': '[' };
  
  for (let char of s) {
    if (char === '(' || char === '{' || char === '[') {
      stack.push(char);
    } else {
      if (stack.pop() !== map[char]) return false;
    }
  }
  return stack.length === 0;
}
```

---

## **9. React-Specific Patterns**

### Custom useDebounce Hook
```javascript
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);
  
  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    
    return () => clearTimeout(handler);
  }, [value, delay]);
  
  return debouncedValue;
}
```

### Custom useAsync Hook
```javascript
function useAsync(asyncFunction, immediate = true) {
  const [status, setStatus] = useState('idle');
  const [value, setValue] = useState(null);
  const [error, setError] = useState(null);
  
  const execute = useCallback(() => {
    setStatus('pending');
    setValue(null);
    setError(null);
    
    return asyncFunction()
      .then(response => {
        setValue(response);
        setStatus('success');
      })
      .catch(error => {
        setError(error);
        setStatus('error');
      });
  }, [asyncFunction]);
  
  useEffect(() => {
    if (immediate) {
      execute();
    }
  }, [execute, immediate]);
  
  return { execute, status, value, error };
}
```

---

## **10. Common Algorithm Patterns**

### Binary Search
```javascript
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    if (arr[mid] === target) return mid;
    if (arr[mid] < target) left = mid + 1;
    else right = mid - 1;
  }
  return -1;
}
```

### Sliding Window Maximum
```javascript
function maxSlidingWindow(nums, k) {
  const result = [];
  const deque = [];
  
  for (let i = 0; i < nums.length; i++) {
    // Remove elements outside window
    if (deque.length && deque[0] <= i - k) {
      deque.shift();
    }
    
    // Remove smaller elements
    while (deque.length && nums[deque[deque.length - 1]] < nums[i]) {
      deque.pop();
    }
    
    deque.push(i);
    
    if (i >= k - 1) {
      result.push(nums[deque[0]]);
    }
  }
  return result;
}
```

---

## **Interview Tips**

### Most Important Topics for Frontend (Priority Order):
1. **Array/Object manipulation** - 40% of questions
2. **Async/Promises** - 20%
3. **Debounce/Throttle/Memoization** - 15%
4. **Tree/DOM traversal** - 10%
5. **String manipulation** - 10%
6. **Design patterns** - 5%

### Companies & Their Focus:
- **Google**: Algorithms heavy, LC Medium/Hard
- **Meta**: System design + medium DSA
- **Amazon**: LC Medium, leadership principles
- **Microsoft**: Balanced DSA + practical problems
- **Uber/Airbnb**: Practical frontend problems
- **Atlassian**: Component design + medium DSA

### Key Points:
- Always discuss time/space complexity
- Think out loud during problem-solving
- Test with edge cases
- Ask clarifying questions
- Know your Big O notation cold
- Practice implementing common JS methods from scratch






| Concept         | Core Idea             | Key Use Case       |
| --------------- | --------------------- | ------------------ |
| Debounce        | Delay execution       | API calls, typing  |
| Throttle        | Limit rate            | Scroll/resize      |
| Event Loop      | Microtask > Macrotask | Async JS order     |
| Promise.all     | Wait for all          | Parallel API calls |
| Deep Clone      | Copy nested data      | Avoid mutation     |
| Memoization     | Cache results         | Performance        |
| call/apply/bind | Control `this`        | Reuse functions    |
| Generators      | Pause/resume          | Iterators, async   |
| myBind          | Custom bind           | JS internals       |
| Closure         | Preserve state        | Counters, hooks    |






Perfect â€” for a **4.5-year experienced React.js Front-End Developer** targeting **FAANG** and **product-based companies**, youâ€™ll face **two types of coding interview questions**:

1. **Front-End (JS, React, Web API, Performance, System Design)**
2. **DSA / Problem-Solving (Leetcode-style, moderate to hard)**

Letâ€™s break this down with **categorized questions**, focusing on whatâ€™s *actually asked* in recent FAANG and top product-based company interviews (Meta, Amazon, Google, Microsoft, Uber, Atlassian, Adobe, etc.).

---

## ðŸ§  1. JavaScript Core Interview Questions (Very Common)

> **Difficulty:** Easy â†’ Medium
> **Frequency:** Very High

### ðŸ”¹ Topics

* Closures & Scope
* Event Loop / Async JS (Promises, async/await)
* this binding / call / apply / bind
* Prototypal inheritance
* Debouncing & Throttling
* Deep vs Shallow Copy
* Currying
* Polyfills
* ES6+ features
* Memory leaks & Garbage collection

### ðŸ”¹ Sample Questions

1. Implement a function for **debounce** and **throttle**.
2. Explain the **event loop** and output of:

   ```js
   console.log(1);
   setTimeout(() => console.log(2));
   Promise.resolve().then(() => console.log(3));
   console.log(4);
   ```
3. Implement a **custom Promise.all()**.
4. Difference between `==` and `===` and how coercion works.
5. Implement a **deep clone** function for an object.
6. Write a **memoization** function for caching results.
7. Explain `call`, `apply`, `bind` with code examples.
8. What are **Generators** and how do you use them?
9. Implement **Function.prototype.myBind()**.
10. How does **closure** work in JS? Give a real-world use case.

---

## âš›ï¸ 2. React.js Interview Questions

> **Difficulty:** Medium â†’ Hard
> **Frequency:** Very High (for product-based frontend roles)

### ðŸ”¹ Core Topics

* Component lifecycle (Class vs Hooks)
* useEffect behavior, cleanup, dependency array
* useMemo, useCallback optimization
* Context API, Redux / Zustand / Recoil
* React 18 concurrency (useTransition, Suspense)
* React performance optimization
* Virtual DOM & Reconciliation
* Controlled vs Uncontrolled components
* Error boundaries
* Code splitting, lazy loading
* Custom hooks

### ðŸ”¹ Sample Questions

1. Explain **reconciliation** and how React decides to re-render.
2. What is **React Fiber**?
3. How to prevent **unnecessary re-renders** in React?
4. Implement a **custom hook for debounced search**.
5. How does **React.lazy** and **Suspense** work?
6. What happens when you call `setState` in React?
7. How do you manage **state at scale** in large applications?
8. What is **useLayoutEffect** vs **useEffect**?
9. How do you handle **API calls and cancellation** in React?
10. Whatâ€™s new in **React 18**?

---

## âš™ï¸ 3. Front-End System Design & Architecture Questions

> **Difficulty:** Medium â†’ Hard
> **Frequency:** High (4+ yrs exp)

### ðŸ”¹ Topics

* Designing scalable SPA
* Code splitting, lazy loading
* Caching & CDN
* Micro-frontend architecture
* Error handling & monitoring (Sentry, New Relic)
* Performance metrics (TTFB, LCP, CLS, etc.)
* SSR / CSR / ISR (Next.js)
* Accessibility (a11y)
* Security (XSS, CSRF, CORS)
* Design patterns in React (HOC, Render Props, Compound components)

### ðŸ”¹ Sample Questions

1. Design a **real-time dashboard** app with React.
2. How would you design **Google Docs front-end** architecture?
3. Explain how youâ€™d **improve performance** of a large React app.
4. How to structure a **component library** for reusability?
5. How to ensure **SEO and performance** for React apps?

---

## ðŸ’» 4. DSA / Problem-Solving (for Front-End Developers)

> **Difficulty:** Medium â†’ Hard
> **Frequency:** Moderate (depends on company)

### ðŸ”¹ Must-Know Data Structures

* Arrays / Strings
* HashMap / Set
* Stack / Queue
* Linked List (less frequent)
* Recursion / Backtracking
* Sliding Window / Two pointers
* Binary Search
* Heap / Priority Queue (rare)
* Graph basics (BFS, DFS â€” occasionally)

### ðŸ”¹ Common Patterns & Sample Questions

| Pattern        | Example Question                               |
| -------------- | ---------------------------------------------- |
| Two Pointers   | Move Zeroes, Container With Most Water         |
| Sliding Window | Longest Substring Without Repeating Characters |
| HashMap        | Group Anagrams, Two Sum                        |
| Stack          | Valid Parentheses, Min Stack                   |
| Recursion      | Permutations, Subsets                          |
| Binary Search  | Search in Rotated Sorted Array                 |
| Sorting        | Merge Intervals, Meeting Rooms                 |
| DP (Light)     | Climbing Stairs, House Robber                  |

### ðŸ”¹ Leetcode-style Examples

1. **Two Sum**
2. **Longest Substring Without Repeating Characters**
3. **Valid Parentheses**
4. **Merge Intervals**
5. **Max Consecutive Ones**
6. **Move Zeroes**
7. **Implement Debounce using Promises**
8. **Deep flatten an object/array**
9. **Implement a simple EventEmitter**
10. **LRU Cache (using Map)**

---

## ðŸ§© 5. Web APIs & Browser Questions

> **Difficulty:** Medium
> **Frequency:** High

### ðŸ”¹ Topics

* Event delegation
* Browser rendering pipeline
* Critical rendering path
* LocalStorage vs SessionStorage vs Cookies
* CORS, Preflight
* HTTP 1.1 vs HTTP 2 vs HTTP 3
* Service Workers / PWA
* WebSockets / SSE
* RequestAnimationFrame vs setTimeout
* IntersectionObserver, MutationObserver

### ðŸ”¹ Sample Questions

1. Explain **Event Delegation** with an example.
2. How does the **browser render a webpage**?
3. Explain the **critical rendering path** and ways to optimize it.
4. How does **Service Worker caching** work in PWAs?
5. Difference between **sessionStorage**, **localStorage**, and **cookies**.

---

## ðŸ§® 6. Coding Challenge-Style JS Implementations (FAANG Favorite)

These are **JavaScript + DSA hybrid** questions:

* Implement `Array.prototype.map()`
* Implement `Promise.allSettled()`
* Implement a **retry function with exponential backoff**
* Create a **scheduler** that limits concurrency (e.g., 3 tasks at a time)
* Implement a **curry** function
* Implement a **pipe() / compose()** utility
* Implement **LRU cache** in JS
* Implement **flattenObject()** and **flattenArray()**

---

## ðŸŽ¯ Preparation Strategy (4.5 yrs React Dev)

| Area                         | Focus                                                                               |
| ---------------------------- | ----------------------------------------------------------------------------------- |
| **DSA**                      | Arrays, Strings, HashMaps, Stack/Queue, Sliding Window, Simple recursion            |
| **JS Deep Dive**             | Event loop, async/await, closures, polyfills                                        |
| **React**                    | Hooks internals, performance optimization, architecture                             |
| **System Design (Frontend)** | App structure, performance, SSR, caching                                            |
| **Project Knowledge**        | Deep dive into past React apps you've built â€” architecture, decisions, optimization |

---

Would you like me to create a **PDF cheat sheet** or **study roadmap (4 weeks)** from these topics â€” tailored specifically for **FAANG front-end interviews** (React-focused)?
That would include:

* Daily/weekly topic plan
* Practice questions links
* Key notes & resources.
